#### 키오스크 프로젝트
# 클래스 정의
Main : 시작 지점이 되는 클래스, public static void main(String[] args)
MenuItem: 세부 메뉴 속성 가지는 클래스
햄버거의 이름, 가격, 설명
예시: ShackBurger, 6.9, 토마토, 양상추, 쉑소스가 토핑된 치즈버거
new MenuItem("ShackBurger", 6.9, "토마토, 양상추, 쉑소스가 토핑된 치즈버거")
Kiosk: 프로그램 순서 및 흐름 제어를 담당하는 클래스
Menu: MenuItem 클래스를 관리하는 클래스
예시 : 버거 메뉴, 음료 메뉴 등 각 카테고리 내에 여러 MenuItem을 포함합니다.
LV별로 단계를 거쳐 이렇게 4개 정도의 클래스를 만들어 서로 객체 지향적 설계를 경험해본다.

### Lv 1. 기본적인 키오스크를 프로그래밍해보자
 요구사항이 가지는 의도
 입력 처리와 간단한 흐름 제어를 복습합니다. (프로그래밍 검증)
 Scanner 활용법, 조건문, 반복문을 재확인하며 입력 데이터를 처리하는 방법 강화
 햄버거 메뉴 출력 및 선택하기
 Scanner를 사용하여 여러 햄버거 메뉴를 출력합니다.
 제시된 메뉴 중 입력받은 숫자에 따라 다른 로직을 실행하는 코드를 작성합니다.
 반복문을 이용해서 특정 번호가 입력되면 프로그램을 종료합니다.
첫 번째로 Main 클래스를 만들어 Scanner를 사용해 입력받은 여러 햄버거 메뉴를 출력할 수 있도록 한다. 반복문을 이용해 메뉴판의 번호별로 특정 로직을 실행할 수 있게끔 한다.

### Lv 2. 객체 지향 설계를 적용해 햄버거 메뉴를 클래스로 관리하기
 요구사항이 가지는 의도
 객체 지향 개념을 학습하고, 데이터를 구조적으로 관리하며 프로그램을 설계하는 방법을 익힙니다.
 햄버거 메뉴를 MenuItem 클래스와 List를 통해 관리합니다.
 MenuItem 클래스 생성하기
 설명 : 개별 음식 항목을 관리하는 클래스입니다. 현재는 햄버거만 관리합니다.
 클래스는 이름, 가격, 설명 필드를 갖습니다.
 main 함수에서 MenuItem 클래스를 활용하여 햄버거 메뉴를 출력합니다.
 MenuItem 객체 생성을 통해 이름, 가격, 설명을 세팅합니다.
 키워드: new
 List를 선언하여 여러 MenuItem을 추가합니다.
 List<MenuItem> menuItems = new ArrayList<>();
 반복문을 활용해 menuItems를 탐색하면서 하나씩 접근합니다.
두 번째로 MenuItem 클래스를 생성해서 List를 통해 개별 음식 항목을 관리한다. 여기서 이름, 가격, 설명을 세팅하고, 반복문을 활용해 menuItems를 하나씩 접근할 수 있도록 한다.

### Lv 3. 객체 지향 설계를 적용해 순서 제어를 클래스로 관리하기
 요구사항이 가지는 의도
 객체 지향 개념을 학습하고, 데이터를 구조적으로 관리하며 프로그램을 설계하는 방법을 익힙니다.
 main 함수에서 관리하던 전체 순서 제어를 Kiosk 클래스를 통해 관리합니다.
 Kiosk 클래스 생성하기
 설명: 키오스크 프로그램의 메뉴를 관리하고 사용자 입력을 처리하는 클래스입니다.
 MenuItem을 관리하는 리스트가 필드로 존재합니다.
 main 함수에서 관리하던 입력과 반복문 로직은 이제 start 함수를 만들어 관리합니다.
 List<MenuItem> menuItems 는 Kiosk 클래스 생성자를 통해 값을 할당합니다.
 Kiosk 객체를 생성하고 사용하는 main 함수에서 객체를 생성할 때 값을 넘겨줍니다.
 요구사항에 부합하는지 검토
 키오스크 프로그램을 시작하는 메서드가 구현되어야 합니다.
 콘솔에 햄버거 메뉴를 출력합니다.
 사용자의 입력을 받아 메뉴를 선택하거나 프로그램을 종료합니다.
 유효하지 않은 입력에 대해 오류 메시지를 출력합니다.
 0을 입력하면 프로그램이 ‘뒤로가기’되거나 ‘종료’됩니다.
세 번째로 Kiosk 클래스를 만들어서 키오스크 프로그램의 메뉴를 관리하고 사용자 입력을 처리할 수 있도록 한다. 1단계에서 main함수에서 관리하던 전체 순서 제어를 이 Kiosk 클래스의 start함수로 가져와서 입력과 반복문 로직을 관리한다.

### Lv 4. 객체 지향 설계를 적용해 음식 메뉴와 주문 내역을 클래스 기반으로 관리하기
 Menu 클래스 생성하기
 설명 : MenuItem 클래스를 관리하는 클래스입니다.
예를 들어, 버거 메뉴, 음료 메뉴 등 각 카테고리 내에 여러 MenuItem을 포함합니다.
 List<MenuItem> 은 Kiosk 클래스가 관리하기에 적절하지 않으므로 Menu 클래스가 관리하도록 변경합니다.
 여러 버거들을 포함하는 상위 개념 ‘버거’ 같은 카테고리 이름 필드를 갖습니다.
 메뉴 카테고리 이름을 반환하는 메서드가 구현되어야 합니다.
네 번째로 Menu 클래스를 만들어서 두번째에 만들었던 MenuItem 클래스를 관리한다. List에 들어있는 MenuItem을 순차적으로 보여주는 함수와 List를 리턴하는 함수를 만든다.

### Lv 5. 캡슐화 적용하기
 MenuItem, Menu 그리고 Kiosk 클래스의 필드에 직접 접근하지 못하도록 설정합니다.
 Getter와 Setter 메서드를 사용해 데이터를 관리합니다.
만들어놓은 MenuItem, Menu, Kiosk 클래스의 필드에 직접 접근하지 못하도록 Getter Setter 메서드를 사용해 캡슐화를 적용하면 끝.


#### 트러블 슈팅
- # 1.
	- 문제 : 처음에는 메뉴판에 있는 숫자 중에서 입력된 숫자에 따라 로직이 수행되는 프로그램이기 때문에 switch문이 더 적합하다고 생각했다. 하지만 진행을 하다보니 이 프로그램은 switch문보다 if문이 더 적합하다고 느껴졌다.
	- 해결 : 마지막에 다시 switch문을 if문으로 수정해서 프로그램의 유연성을 높였다. 그런데 switch문을 작성하면서도 굳이 if문 대신 switch문을 쓸 메리트가 있나 생각이 들긴 했었다.

- # 2.
	- 문제 : 조건문안에서 '0을 입력하면 프로그램을 종료시키는 기능'이 구현되어야 하기 때문에 전체를 while(true)로 무한루프 시키게 된다면 이번 조건문만 종료되고 다시 루프가 반복되고 전체 프로그램은 다시 루프를 돌게 된다.
	- 해결 : boolean running = true; 라는 코드를 추가해 프로그램의 실행 상태를 제어할 수 있는 running이라는 변수를 만들고 while(running)으로 루프를 돌렸다.
      		이렇게 해서 조건문 안에서 0을 입력받으면 먼저 running에 false값을 넣어서 while루프를 종료시킬 수 있다.

- # 3.
	- 문제 : MenuItem클래스에서 display 메서드를 만들어놓고, Main클래스로 돌아와서 menuItems.display() 로 사용을 하려고 했는데 사용할 수가 없었다.
	- 해결 : menuItems는 현재 List타입이기 때문이였다. display()는 MenuItem클래스에 정의된 메서드이지 List 자체에는 display() 메서드가 없기 때문에 호출이 불가능한 것 이였다.
      		그래서, menuItems.get(i) 을 사용해 먼저 List에서 MenuItem 객체를 꺼내와서 이 객체에서 display() 메서드를 호출하였다.

- # 4.
	- 문제 : 숫자를 입력받을 때, 숫자 이외의 입력을 받으면 에러가 뜨는 기능을 구현하고 싶다. 그래서 Scanner 객체에 입력값이 int일 때만 true를 반환해주는 메서드인 scanner.hasNextInt() 라는 메서드를 찾았다.
      		그런데, 숫자 이외의 입력을 했을 때 잘못된 입력이라는 문구가 뜨고 나서도 프로그램이 무한정으로 잘못된 입력을 받는 걸 반복하고 있다는 것을 확인했다.
	- 해결 : "잘못된 입력입니다. 숫자를 입력해주세요." 라는 문구가 뜨고 나서 다시 숫자를 입력하는 곳으로 루프했을 때 그대로 아까 전 잘못된 입력이 사라지지 않고 입력되면서 계속 반복이 되는 듯 했다.
   		그럼 이 문제를 해결하려면 어떻게 해야 할까? 당연히 잘못된 입력을 제거를 해야 다시 숫자를 입력하는 곳으로 루프했을 때 새로 입력을 할 수 있다.
   		잘못된 입력을 하고 나면 그 잘못된 입력이 이 입력 버퍼에 저장되고, 루프가 될 때마다 여기 저장되어 있는 잘못된 입력이 계속 조건문에 들어가는 것이다.
   		이를 해결할 수 있는 것이 scanner.next()인데, scanner.next()는 입력 버퍼에서 다음 토큰(단어 단위 데이터)을 읽는다. "토큰"은 공백(스페이스, 탭) 또는 줄바꿈 문자로 구분된다.
		scanner.next()가 호출되면:
		입력 버퍼에서 공백이나 줄바꿈 문자로 구분된 첫 번째 토큰을 읽는다.
		읽은 데이터는 프로그램에 반환되고, 입력 버퍼에서는 제거된다.
		결론 :
		입력 버퍼가 ["abc", "\n"] 상태에서 scanner.next()가 호출되면:
		"abc"를 읽어오고 버퍼에서 제거.
		결과적으로 입력 버퍼는 ["\n"]만 남는다.

- # 5.
	- 문제 : 기존에 0을 입력받으면 프로그램을 종료하기 위해 running = false; 로 먼저 무한루프를 종료시키고 프로그램을 완전히 종료했었는데, 
      		Kiosk클래스로 이 기능들을 옮겨오고 메서드별로 관리를 하려다 보니 이 코드들이 while문 밖으로 나와있는 상태다. 그래서 running = false;를 사용할 수가 없게 되었다.
	- 해결 : 프로그램 실행 상태를 속성으로 관리하기 위해 Kiosk클래스에 running이라는 변수를 필드로 선언했다. 따라서 생성자에서도 this.running = true; 로 초기값을 설정해주었다.
		그런데 실행을 하고보니 에러가 발생하는 곳은 없었는데, 0을 입력했을 때 "프로그램이 종료되었습니다." 문구는 뜨지만 루프가 종료되지않고 다시 반복하여 프로그램이 진행되는 문제가 발생했다. 
		handleInput 메서드에서 running = false; 이라는 코드가 있는데 왜 루프가 반복되는걸까 생각했는데, Kiosk클래스에서 필드 변수로 boolean running; 을 선언했고 생성자에서 초기값 this.running = true; 로 설			정해놨는데, start 메서드에서도 아직 boolean running = true; 라는 코드가 남아있는 것을 발견했다. 따라서 start메서드안의 로컬 변수 running을 선언한 것은 Kiosk클래스의 필드 변수 this.running 과 다른 변수			로 취급되어서, handleInput메서드에서 running = false 로 설정해봤자 start 메서드 안의 로컬 변수 running에는 아무 영향을 미치지 않았던 것이다.
		그래서 start메서드의 running 변수 선언 부분을 삭제했더니 0을 입력했을 때 정상적으로 프로그램이 종료되는 것까지 확인했다.

- # 6.
	- 문제 : 숫자를 입력하고 나서 예외처리 부분에서 문제가 있어서 원하는대로 결과가 나오지 않았다. switch문을 제대로 사용하지 못한 것으로 보인다.
	- 해결 : 케이스별로 모두 break;를 걸어주니 정상적으로 프로그램이 기능했다. 결과적으로는 이후 if문으로 바꿨지만, switch문에 대한 사용이 미숙한 점을 확인할 수 있었다.

- # 7.
	- 문제 : 처음 카테고리 번호를 입력할 때는 scanner.hasNextInt() 으로 입력값이 int일 때만 true를 반환해주는 메서드를 사용해서 예외처리를 해놨었는데, 
      		그 다음 handleInput 메서드로 들어와서 메뉴 번호를 입력받을 때는 정수 외의 입력값을 받을 때에 대한 예외처리가 안되어 있었다.
	- 해결 : handleInput메서드 안에도 똑같이 
		if (scanner.hasNextInt()) {
		} else {
			System.out.println("잘못된 입력입니다. 숫자를 입력해주세요.");
		  scanner.next(); // 잘못된 입력 제거
		}
		코드를 추가해서 예외처리를 해주었다.

- # 8.
	- 문제 : Kiosk클래스에서 start메서드와 handleInput메서드에서 각각 scanner를 생성했다.
	- 해결 : 이런 중복코드를 없애기 위해 Kiosk클래스의 속성에 scanner를 추가해놓음으로써 한 곳에서 관리할 수 있게 되었다.

- # 9.
	- 문제 : Main클래스에서 메뉴들의 이름,가격,설명을 작성하는 부분이 코드 중복이 너무 많다.
	- 해결 : 배열에 메뉴 데이터를 정의하고 향상된 for문을 사용해 addMenu 호출을 반복문으로 처리했다.
